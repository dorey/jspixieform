// Generated by CoffeeScript 1.12.6

/*
This module is carried over from model.inputParser.coffee

It converts a flat array into a nested array where grouped questions
are bunched together.

The output os a JSON serializable structure like this:

[
  {
    "type": "group",
    "name": "grp1",
    "$kuid": "aaa",
    "__rows": [
      {
        "type": "group",
        "name": "grp2",
        "$kuid": "bbb",
        "__rows": [
          {
            "type": "text",
            "name": "q1",
            "$kuid": "ccc"
          },
          {
            "type": "text",
            "name": "q2",
            "$kuid": "ddd"
          }
        ]
      }
    ]
  }
]
 */

(function() {
  var $aliases, ParsedStruct, rowGrouper;

  $aliases = require('./aliases');

  ParsedStruct = (function() {
    function ParsedStruct(type1, atts) {
      this.type = type1;
      this.atts = atts != null ? atts : {};
      this.contents = [];
    }

    ParsedStruct.prototype.push = function(item) {
      this.contents.push(item);
      return ;
    };

    ParsedStruct.prototype["export"] = function() {
      var arr, i, item, len, ref;
      arr = [];
      ref = this.contents;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item instanceof ParsedStruct) {
          item = item["export"]();
        }
        arr.push(item);
      }
      return Object.assign({}, this.atts, {
        type: this.type,
        __rows: arr
      });
    };

    return ParsedStruct;

  })();

  rowGrouper = function(rows) {
    var _curGrp, _groupAtts, _popGrp, _pushGrp, count_att, counts, grpStack, i, item, len;
    counts = {
      open: {},
      close: {}
    };
    count_att = function(opn_cls, att) {
      var base;
      if ((base = counts[opn_cls])[att] == null) {
        base[att] = 0;
      }
      counts[opn_cls][att]++;
      return ;
    };
    grpStack = [new ParsedStruct('survey')];
    _pushGrp = function(type, item) {
      var grp;
      if (type == null) {
        type = 'group';
      }
      count_att('open', type);
      grp = new ParsedStruct(type, item);
      _curGrp().push(grp);
      return grpStack.push(grp);
    };
    _popGrp = function(closedByAtts, type) {
      var _grp;
      count_att('close', type);
      _grp = grpStack.pop();
      if (_grp.type !== closedByAtts.type) {
        throw new Error("mismatched group/repeat tags");
      }
      return ;
    };
    _curGrp = function() {
      var _l;
      _l = grpStack.length;
      if (_l === 0) {
        throw new Error("unmatched group/repeat");
      }
      return grpStack[_l - 1];
    };
    for (i = 0, len = rows.length; i < len; i++) {
      item = rows[i];
      _groupAtts = $aliases.q.testGroupable(item.type);
      if (_groupAtts) {
        if (_groupAtts.begin) {
          _pushGrp(_groupAtts.type, item);
        } else {
          _popGrp(_groupAtts, item.type);
        }
      } else {
        _curGrp().push(item);
      }
    }
    if (grpStack.length !== 1) {
      throw new Error(JSON.stringify({
        message: "unclosed groupable set",
        counts: counts
      }));
    }
    return _curGrp()["export"]().__rows;
  };

  module.exports = {
    rowGrouper: rowGrouper
  };

}).call(this);
